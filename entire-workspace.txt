<file_map>
/Users/Maksimus/Documents/GitHub/max--
├── grammar
│   └── grammar.txt
├── include
│   ├── arena
│   │   ├── arena_test.h
│   │   └── arena.h
│   ├── ast
│   │   ├── lexer
│   │   │   └── lexer.h
│   │   ├── parser
│   │   │   ├── ast_printer.h
│   │   │   ├── ast.h
│   │   │   └── parser.h
│   │   └── ast_node.h
│   ├── errors
│   │   └── diagnostics.h
│   ├── semantics
│   │   └── scope.h
│   ├── common.h
│   └── debug.h
├── src
│   ├── arena
│   │   ├── arena_test.c
│   │   └── arena.c
│   ├── ast
│   │   ├── lexer
│   │   │   └── lexer.c
│   │   └── parser
│   │       ├── ast_printer.c
│   │       └── parser.c
│   ├── errors
│   │   └── diagnostics.c
│   ├── semantics
│   │   └── scope.c
│   ├── common.c
│   ├── debug.c
│   └── main.c
├── tests
│   └── testfiles
│       ├── blocks
│       │   └── block_dec.in
│       ├── cf
│       │   └── if-else.in
│       ├── decs
│       │   ├── int_dec.in
│       │   └── int_dec.out
│       ├── ops
│       │   ├── add.in
│       │   └── complex.in
│       ├── playground
│       │   └── test.m
│       └── strings
│           └── hello_world.in
├── CMakeLists.txt
├── compile.sh
└── README.md

</file_map>

<file_contents>
File: /Users/Maksimus/Documents/GitHub/max--/src/ast/parser/parser.c
```c
#include <stdalign.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "ast/lexer/lexer.h"
#include "ast/parser/parser.h"
#include "ast/parser/ast.h"
#include "arena/arena.h"
#include "debug.h"
#include "common.h"

#define AST_DEFAULT_CAPACITY 32
#define DEFAULT_ERR_MSG_SIZE 100

void parse_item_list(Parser* parser, NodeList* list, Source* source_file, enum TokenKind stop_cond);
char* alloc_error_ptr(Parser* parser);

/*--------- HELPERS --------- */
// Checkers
/* Peeks n tokens ahead (or behind?) and returns the token, unless EOF.*/
Token peek_n(Parser* parser, int n) {
    int token_index = parser->token_index;

    // TODO: Make this error check more robust
    assert(0 <= token_index && token_index < (int)parser->tokens->count);
    if (0 <= token_index + n && token_index + n < (int)parser->tokens->count) {
        return parser->tokens->data[token_index+n];
    }
    return parser->tokens->data[parser->tokens->count-1];
}

/* Get next token in tokens. Does not advance token index. */
Token next(Parser* parser) {
    return peek_n(parser, 1);
}

/* Grab current token in tokens, does not advance token index */
Token current(Parser* parser) {
    return peek_n(parser, 0);
}

// Consumers
/* Returns true if CURRENT token matches expectation (& consume), false otherwise.
 Used when next token is mandatory.*/
int expect(Parser* parser, enum TokenKind kind, char* err_msg) {
    if (current(parser).token_kind == kind) {
        parser->token_index++;
        return 1;
    }
    else {
        // Error handling by returning expected tokens.
        int curr_index = parser->token_index;

        assert((size_t)curr_index + 1 <= parser->tokens->count);
        enum TokenKind curr_token = parser->tokens->data[curr_index].token_kind;
        const char* curr_token_str = token_kind_str[curr_token];
        const char* expected_token_str = token_kind_str[kind];
        /*
        LineCol line_col;
        line_col.line = current(parser).line;
        line_col.col = current(parser).col;*/

        // Todo: Check which token was expected.
        int res = snprintf(err_msg, DEFAULT_ERR_MSG_SIZE, "Expected %s after %s", expected_token_str, curr_token_str);
        return 0;
    }
}

// Advance our token pointer by n tokens (or EOF)
int advance_n(Parser* parser, int n) {
    int token_index = parser->token_index;
    int total_token_count = parser->tokens->count;
    if (token_index + n < total_token_count) {
        parser->token_index += n;
        return 1;
    }
    else {
        parser->token_index = parser->tokens->count-1;
        return 0;
    }
    // TODO: Use T/F returned from this
}

// Advance token pointer by 1 token (or to EOF)
int advance(Parser* parser) {
    return advance_n(parser, 1);
}

// Returns true if CURRENT tokens match, and consumes token. 
// Used when next token is optional.
int match_kind(Parser* parser, enum TokenKind kind) {
    if (parser->token_index >= (int)parser->tokens->count-1) {
        return 0;
    }

    if (current(parser).token_kind == kind) {
        parser->token_index++;
        return 1;
    }
    return 0;
}

// Returns true if token matches one of the tokens given in the list, and consumes token
int match_one_of_kinds(Parser* parser, enum TokenKind* kind, int size) {
    if (parser->token_index >= (int)parser->tokens->count-1) {
        return 0;
    }
    for (int j = 0; j < size; j++) {
        if (current(parser).token_kind == kind[j]) {
            parser->token_index++;
            return 1;
        }
    }
    return 0;
}

/*--------- VISIT_[NODE] --------- */


// True if current token starts a declaration
int starts_decl(Parser* parser) {
    switch (current(parser).token_kind) {
        // TODO: Add rest of declarations.
        // Consider making a 'TYPE' that
        // encapsulates all types as checks.
        case INT:
            return 1;
            break;
        case FN:
            return 1;
            break;
        default:
            return 0;
            break;
    }
}

// True if current token starts a statement
int starts_stmt(Parser* parser) {
    switch (current(parser).token_kind) {
        // TODO: Add rest of statements.
        case IF:
            return 1;
            break;
        case WHILE:
            return 1;
            break;
        case RETURN:
            return 1;
            break;
        case CUR_BRACK_START: // block start
            return 1;
            break;
        default:
            return 0;
            break;
    }
}

// Compares name of IDENTIFIER to given string.
int compare_identifier_name(Parser* parser, Source* source_file, char* compare_to, size_t length) {
    if (current(parser).length != length) return 0;

    
    char* start_ptr = &source_file->buffer[current(parser).start];
    if (memcmp(start_ptr, compare_to, length) == 0) {
        return 1;
    }
    return 0;
}

int starts_builtin_func(Parser* parser, Source* source_file) {
    if (!(current(parser).token_kind == IDENTIFIER)) return 0;
    switch (current(parser).length) {
        case 4:
        {
            if (compare_identifier_name(parser, source_file, "exit", 4)) {
                if (next(parser).token_kind == PAREN_START) {
                    return 1;
                }
            }
            return 0;
        }

        default:
            return 0;
    }
    return 0;
}

// Create a span struct for metadata storage
SrcSpan create_span_from(int start_mark, int end_mark) {
    SrcSpan span;
    span.start = start_mark;
    span.length = end_mark - start_mark;

    return span;
}

/*--------- ERROR RECOVERY ---------*/
/*Help recover from syntax errors by syncing to
 closest statment boundary or EOF.*/
int sync_to_boundary(Parser* parser) {
    while (parser->token_index < (int)parser->tokens->count-1) {
        if (starts_stmt(parser)) break;
        else if (current(parser).token_kind == CUR_BRACK_END) break;
        else if (match_kind(parser, SEMICOLON)) break;
        parser->token_index++;
    }
    return parser->token_index;
}

/*Help recover from syntax errors by syncing to
 closest semicolon or EOF.*/
int expect_semicolon_or_recover(Parser* parser) {
    while (parser->token_index < (int)parser->tokens->count-1) {
        if (match_kind(parser, SEMICOLON)) break;
        parser->token_index++;
    }
    // TODO: This should probably return an error since we reached EOF.
    return parser->token_index;
}

/*--------- PARSING HELPERS ---------*/
// Converts integer literal string to actual integer
long get_int_lit_value(Parser* parser, Source* source_file) {
    // TODO: Maybe move into lexer?
    int index = parser->token_index;
    int start = parser->tokens->data[index].start;
    int end = start + parser->tokens->data[index].length;

    long value = 0;
    for (int i = start; i < end; i++) {
        char c = source_file->buffer[i];
        if (c < '0' || c > '9') {
            // error: non-digit in integer literal
            value = -1;
            break;
        }
        int digit = c - '0';
        // TODO: Add overflow check
        value = value * 10 + digit;
    }

    return value;
}

/*--------- PARSE_{NODE} ---------*/
// parses expression, moves pointer to end of expr.
// Assumes pointer is at start of expression.
ASTNode* parse_expr(Parser* parser, Source* source_file) {
    ASTNode* expr = (ASTNode*)arena_alloc(parser->ast_arena, sizeof(ASTNode), alignof(ASTNode));

    if (current(parser).token_kind == INT_LITERAL) {
        // todo: parse -(unary op)
        expr->ast_kind = AST_INT_LIT;
        expr->node_info.int_lit = (IntLitInfo) {
            .value = get_int_lit_value(parser, source_file)
        };
        advance(parser);
    }
    else if (current(parser).token_kind == IDENTIFIER) {
        // TODO: Check entirety of expression.
        // For now we'll focus on single identifiers on RHS.
        expr->ast_kind = AST_NAME;
        expr->node_info.var_name.name_span = create_span_from(parser->tokens->data[parser->token_index].start, 
            parser->tokens->data[parser->token_index].start + parser->tokens->data[parser->token_index].length);
        advance(parser);
    }
    else { // error
        expr->ast_kind = AST_ERROR;
        add_err_msg(parser, "Could not parse expression.", current(parser).line, current(parser).col);
    }
    // TODO: Parse real expressions, not just integer literals.

    return expr;
}

ASTNode* parse_int_decl(Parser* parser, Source* source_file) {
    /*  Parses:
        int x; (not yet implemented)
        int x = {expr};
        Pointer assumed to be at 'INT'.
    */
    // TODO: Get the span of this declaration.
    ASTNode* int_decl = (ASTNode*)arena_alloc(parser->ast_arena, sizeof(ASTNode), alignof(ASTNode));
    int_decl->ast_kind = AST_VAR_DEC;

    char* err_msg = arena_alloc(parser->ast_arena,
                            DEFAULT_ERR_MSG_SIZE,
                            alignof(char));
    // Find identifier, store its span
    advance(parser);
    SrcSpan name_span;
    if (expect(parser, IDENTIFIER, err_msg)) {
        name_span = create_span_from(parser->tokens->data[parser->token_index-1].start, 
            parser->tokens->data[parser->token_index-1].start + parser->tokens->data[parser->token_index-1].length);
    }
    else {
        // Move pointer to next safe boundary
        int_decl->ast_kind = AST_ERROR;
        add_err_msg(parser, err_msg, current(parser).line, current(parser).col);
        sync_to_boundary(parser);
        return int_decl;
    }

    // Check type of declaration (assignment or pure decl)
    if (match_kind(parser, EQ)) {
        ASTNode* expr_node = parse_expr(parser, source_file);

        int_decl->node_info.var_decl = (struct VarDeclInfo){
            .name_span = name_span,
            .type = TYPE_INT,
            .init_expr = expr_node
        };
    }
    else {
        // TODO: Get specific identifier name and append to error list.
        int_decl->ast_kind = AST_ERROR;
        add_err_msg(parser, "Error: expected '=' after IDENTIFIER", current(parser).line, current(parser).col);
        expect_semicolon_or_recover(parser);
        return int_decl;
    }
    
    char* err_msg_2 = arena_alloc(parser->ast_arena,
                            DEFAULT_ERR_MSG_SIZE,
                            alignof(char));
    if (!expect(parser, SEMICOLON, err_msg_2)) {
        int_decl->ast_kind = AST_ERROR;
        add_err_msg(parser, err_msg_2, current(parser).line, current(parser).col);
    }

    return int_decl;
}

// Parses statements/decls inside block. Assumes { was consumed.
ASTNode* parse_block_node(Parser* parser, Source* source_file) {
    ASTNode* block_node = (ASTNode*)arena_alloc(parser->ast_arena, sizeof(ASTNode), alignof(ASTNode));
    block_node->ast_kind = AST_BLOCK;

    block_node->node_info.block_info.body = (NodeList) {
        .items = (ASTNode**)arena_alloc(parser->ast_arena, AST_DEFAULT_CAPACITY * sizeof(ASTNode*), alignof(ASTNode*)),
        .capacity = AST_DEFAULT_CAPACITY,
        .count = 0
    };

    // Recursively fill items from while expr inside build_ast?
    // Make it a sub-routine?
    parse_item_list(parser, &block_node->node_info.block_info.body, source_file, CUR_BRACK_END);
    if (current(parser).token_kind == CUR_BRACK_END) advance(parser);
    else {
        add_err_msg(parser, "Expected '}'.", current(parser).line, current(parser).col);
        sync_to_boundary(parser);
    }

    return block_node;
}

// Parses builtin function 'exit(<expr>)'.
// Assumes we start on 'exit' token.
ASTNode* parse_exit(Parser* parser, Source* source_file) {

    ASTNode* exit_node = (ASTNode*)arena_alloc(parser->ast_arena, sizeof(ASTNode), alignof(ASTNode));
    exit_node->ast_kind = AST_EXIT;
    // TODO: Get span of the entire function (usually up to ;)
    // we already verified the next token is '('.
    advance(parser);
    char* err_msg = alloc_error_ptr(parser);
    expect(parser, PAREN_START, err_msg);

    ASTNode* expr = parse_expr(parser, source_file);
    exit_node->node_info.exit_info.expr = expr;

    // Pointer is after expression now
    char* err_msg_2 = alloc_error_ptr(parser);
    if (!expect(parser, PAREN_END, err_msg)) {
        add_err_msg(parser, err_msg_2, current(parser).line, current(parser).col);
        sync_to_boundary(parser);
        return exit_node;
    }
    char* err_msg_3 = alloc_error_ptr(parser);
    if (!expect(parser, SEMICOLON, err_msg_3)) {
        add_err_msg(parser, err_msg_3, current(parser).line, current(parser).col);
        sync_to_boundary(parser);
    }

    return exit_node;
}



/*------ ITEM HELPER ------ */
void ensure_item_capacity(Parser* parser, NodeList* list) {
    if (list->capacity == list->count) {
        size_t new_capacity = list->capacity * 2;
        ASTNode** new_items = (ASTNode**)arena_alloc(parser->ast_arena, new_capacity * sizeof(ASTNode*), alignof(ASTNode*));
        if (!new_items) {
            // TODO: Error handle better.
            fprintf(stderr, "ERROR: Could not allocate new items list for 'program' from arena.");
            return;
        }
        if (list->count > 0) {
            memcpy(new_items, list->items, list->count * sizeof(ASTNode*));
        }
        list->capacity = new_capacity;
        list->items = new_items;
        return;
    }
}

void push_node(Parser* parser, NodeList* list, ASTNode* node) {
    // TODO: Handle errors pushing to list!
    ensure_item_capacity(parser, list);

    size_t count = list->count;
    list->items[count] = node;
    list->count++;
}

/*------ ERROR MESSAGE HELPERS ------*/

// Adds error message with line/col to error list during parsing.
void add_err_msg(Parser* parser, char* err_msg, size_t line, size_t col) {
    char* new_err_msg = arena_alloc(parser->ast_arena,
                            DEFAULT_ERR_MSG_SIZE,
                            alignof(char));

    snprintf(new_err_msg, DEFAULT_ERR_MSG_SIZE, "Error at (%zu:%zu): %s", line, col, err_msg);
    if (parser->error_list_size < DEFAULT_ERROR_LIST_SIZE) {
        parser->error_list[parser->error_list_size] = new_err_msg;
        parser->error_list_size++;
    }
}

// True if errors were present.
int print_parser_err_msgs(Parser* parser) {
    if (parser->error_list_size == 0) return 0;
    fprintf(stdout, "Parser errors:\n");
    for (int i = 0; i < parser->error_list_size; i++) {
        fprintf(stdout, "%s\n", parser->error_list[i]);
    }
    return 1;
}

// Allocates memory for an error message (if we need it).
char* alloc_error_ptr(Parser* parser) {
    return arena_alloc(parser->ast_arena,
                    DEFAULT_ERR_MSG_SIZE,
                    alignof(char));
}

void parse_item_list(Parser* parser, NodeList* list, Source* source_file, enum TokenKind stop_cond) {

    while (current(parser).token_kind != stop_cond && current(parser).token_kind != TOK_EOF) {
        if (starts_decl(parser)) {
            switch (current(parser).token_kind) {
                case INT:
                    // TODO: Just call 'parse_int_decl' and let that handle missing identifier.
                    if (next(parser).token_kind == IDENTIFIER) {
                        ASTNode* int_decl = parse_int_decl(parser, source_file);
                        push_node(parser, list, int_decl);
                    }
                    else {
                        add_err_msg(parser, "Expected 'IDENTIFIER' after 'int'.", current(parser).line, current(parser).col);
                        expect_semicolon_or_recover(parser);
                    }
                    break;
                default:
                    break;
            }
        }
        else if (starts_builtin_func(parser, source_file)) {
            if (compare_identifier_name(parser, source_file, "exit", 4)) {
                ASTNode* builtin_exit = parse_exit(parser, source_file);
                push_node(parser, list, builtin_exit);
            }
        }
        else if (current(parser).token_kind == CUR_BRACK_START) {
            advance(parser);
            ASTNode* block_node = parse_block_node(parser, source_file);
            push_node(parser, list, block_node);
        }
        else {
            add_err_msg(parser, "Unexpected token.", current(parser).line, current(parser).col);
            //TODO* Remove this once more things r implemented.
            // I want each 'parse_x' to advance the pointer to proper place
            parser->token_index++;
        }

        // todo: Error checking after each built node
        /*I define parse_{node} for each node. */
    }
}

ASTNode* build_ast(Parser* parser, Source* source_file) {

    ASTNode* ast_root = (ASTNode*)arena_alloc(parser->ast_arena, sizeof(ASTNode), alignof(ASTNode));

    ast_root->ast_kind = AST_PROGRAM;
    ast_root->span = create_span_from(parser->token_index, parser->tokens->count-1);
    ast_root->node_info.program.body = (NodeList) {
        .items = (ASTNode**)arena_alloc(parser->ast_arena, AST_DEFAULT_CAPACITY * sizeof(ASTNode*), alignof(ASTNode*)),
        .capacity = AST_DEFAULT_CAPACITY,
        .count = 0
    };
    parse_item_list(parser, &ast_root->node_info.program.body, source_file, TOK_EOF);

    return ast_root;
}


int initialize_parser(Parser* parser, Arena* arena, TokenBuffer* tokens) {
    parser->ast_arena = arena;
    parser->token_index = 0;
    parser->tokens = tokens;
    parser->error_list_size = 0;
    return 1;
}

int free_ast_arena(Parser* parser) {
    if (!arena_destroy(parser->ast_arena)) {
        fprintf(stderr, "Failed to destroy AST arena.");
        return 1;
    }
    return 0;
}

```

File: /Users/Maksimus/Documents/GitHub/max--/src/arena/arena_test.c
```c
/* GENERATED WITH CHATGPT! I WAS TOO LAZY TO WRITE TESTS! */
// arena_tests.c
// Quick, pullable test functions for your arena allocator.
//
// Usage (example main):
//   #include "arena/arena.h"
//   int main(void) {
//       Arena a = {0};
//       arena_init(&a, 0);
//
//       test_arena_alignment(&a);
//       test_arena_no_overlap(&a);
//       test_arena_block_growth(&a);
//       test_arena_reset_reuse(&a);
//
//       arena_destroy(&a);
//       return 0;
//   }
//
// Suggested build flags (clang/gcc):
//   -g -O0 -Wall -Wextra -Wpedantic
//   -fsanitize=address,undefined -fno-omit-frame-pointer
//
// Notes:
// - These tests assume your arena_alloc expects power-of-two alignments.
// - These tests touch Arena internals (curr_block/start_block) on purpose.
/* Forward declarations (needed because ARENA_DUMP uses these) */
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <stdalign.h>
#include <assert.h>

#include "arena/arena.h"


static void arena_print_layout(const Arena* arena);
static void hexdump_lines(const void* p, size_t n);
#if defined(MAXC_ARENA_DUMP) && MAXC_ARENA_DUMP
#  define ARENA_DUMP(tag, arena_ptr) do { \
        printf("=== ARENA DUMP: %s ===\n", (tag)); \
        arena_print_layout((arena_ptr)); \
    } while (0)
#else
#  define ARENA_DUMP(tag, arena_ptr) do { (void)(tag); (void)(arena_ptr); } while (0)
#endif

/* ---- configurable dump limits ---- */
#ifndef ARENA_DUMP_MAX_BYTES_PER_BLOCK
#define ARENA_DUMP_MAX_BYTES_PER_BLOCK 64
#endif



#ifndef TEST_ASSERT
#define TEST_ASSERT(expr) do { \
    if (!(expr)) { \
        fprintf(stderr, "[FAIL] %s:%d: %s\n", __FILE__, __LINE__, #expr); \
        assert(expr); \
    } \
} while (0)
#endif

static int is_aligned_to(const void* p, size_t align) {
    // align must be power of 2
    return (((uintptr_t)p) & (align - 1)) == 0;
}

static void fill_bytes(void* p, size_t n, unsigned char value) {
    memset(p, value, n);
}

static void assert_all_bytes(const void* p, size_t n, unsigned char value) {
    const unsigned char* b = (const unsigned char*)p;
    for (size_t i = 0; i < n; i++) {
        if (b[i] != value) {
            fprintf(stderr,
                    "[FAIL] byte mismatch at i=%zu: got=0x%02X expected=0x%02X\n",
                    i, (unsigned)b[i], (unsigned)value);
            TEST_ASSERT(0);
        }
    }
}

static int ranges_overlap(const unsigned char* a, size_t asz,
                          const unsigned char* b, size_t bsz) {
    // [a, a+asz) overlaps [b, b+bsz) ?
    return (a < b + bsz) && (b < a + asz);
}

/* ------------------------------
   Test A: alignment is correct
   ------------------------------ */
void test_arena_alignment(Arena* arena) {
    printf("[TEST] alignment\n");

    // Mix some sizes/alignments to force padding behavior.
    // We intentionally allocate in an order that will create misaligned "used"
    // before requesting a larger alignment.
    void* p1 = arena_alloc(arena, sizeof(char), alignof(char));      // align 1
    void* p2 = arena_alloc(arena, sizeof(int), alignof(int));        // align 4
    void* p3 = arena_alloc(arena, sizeof(double), alignof(double));  // align typically 8
    void* p4 = arena_alloc(arena, sizeof(void*), alignof(void*));    // align pointer

    TEST_ASSERT(p1 && p2 && p3 && p4);

    TEST_ASSERT(is_aligned_to(p1, alignof(char)));
    TEST_ASSERT(is_aligned_to(p2, alignof(int)));
    TEST_ASSERT(is_aligned_to(p3, alignof(double)));
    TEST_ASSERT(is_aligned_to(p4, alignof(void*)));

    // Optional: a struct with higher alignment
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
typedef struct Aligned16 {
    long double force_align; // typically 16-byte aligned
    char x[16];
} Aligned16;
#endif

    printf("[PASS] alignment\n");
}

/* --------------------------------
   Test B: allocations don’t overlap
   -------------------------------- */
void test_arena_no_overlap(Arena* arena) {
    printf("[TEST] no-overlap\n");

    const size_t N = 32;

    unsigned char* a = (unsigned char*)arena_alloc(arena, N, alignof(unsigned char));
    unsigned char* b = (unsigned char*)arena_alloc(arena, N, alignof(unsigned char));

    TEST_ASSERT(a && b);

    // If the ranges overlap, patterns will collide or this will explicitly detect it.
    TEST_ASSERT(!ranges_overlap(a, N, b, N));

    fill_bytes(a, N, 0xAA);
    fill_bytes(b, N, 0xBB);

    // Ensure b didn't clobber a
    assert_all_bytes(a, N, 0xAA);
    assert_all_bytes(b, N, 0xBB);

    printf("[PASS] no-overlap\n");
}

/* -------------------------------
   Test C: block growth works
   ------------------------------- */
void test_arena_block_growth(Arena* arena) {
    printf("[TEST] block-growth\n");

    // We’ll allocate enough to force arena_add_block.
    // We detect growth by seeing curr_block change from start_block.
    MemBlock* start = arena->start_block;
    TEST_ASSERT(start != NULL);

    // Keep a pointer from the first block and make sure it stays valid after growth.
    unsigned char* sentinel = (unsigned char*)arena_alloc(arena, 64, alignof(max_align_t));
    TEST_ASSERT(sentinel);
    fill_bytes(sentinel, 64, 0xCC);

    // Allocate in medium chunks until we see a new block.
    // Chunk size: 1024 tends to trigger growth quickly without being too huge.
    const size_t chunk = 1024;
    const size_t iters = 20000; // upper bound; should break much earlier

    MemBlock* before = arena->curr_block;
    TEST_ASSERT(before != NULL);

    MemBlock* grew_to = NULL;
    for (size_t i = 0; i < iters; i++) {
        void* p = arena_alloc(arena, chunk, alignof(max_align_t));
        TEST_ASSERT(p);

        if (arena->curr_block != start) {
            grew_to = arena->curr_block;
            break;
        }
    }

    TEST_ASSERT(grew_to != NULL);           // must have grown to a new block
    TEST_ASSERT(arena->curr_block != NULL); // still valid

    // Ensure earlier memory is still intact.
    assert_all_bytes(sentinel, 64, 0xCC);

    printf("[PASS] block-growth (start=%p curr=%p)\n", (void*)start, (void*)arena->curr_block);
}

/* -------------------------------------
   Extra: reset reuses memory as expected
   ------------------------------------- */
void test_arena_reset_reuse(Arena* arena) {
    printf("[TEST] reset-reuse\n");

    // Allocate something and remember pointer; then reset and allocate same shape.
    void* p1 = arena_alloc(arena, 128, alignof(max_align_t));
    TEST_ASSERT(p1);
    fill_bytes(p1, 128, 0x5A);

    // Move forward a bit
    void* p2 = arena_alloc(arena, 64, alignof(max_align_t));
    TEST_ASSERT(p2);
    (void)p2;

    // Reset should put curr_block back to start and used=0 everywhere.
    TEST_ASSERT(arena_reset(arena) == 0);

    // printf("Starting used & curr block used: %d %d\n", (int)arena->start_block->used, (int)arena->curr_block->used);
    // printf("start block address: %p\n", (void*)&arena->start_block);
    // printf("start block capacity: %d\n", (int)arena->start_block->capacity);

    void* p1_again = arena_alloc(arena, 128, alignof(max_align_t));
    // printf("p1 and p1_again: %p %p\n", p1, p1_again);
    // printf("Start block & curr block: %p %p\n", (void*)arena->start_block, (void*)arena->curr_block);
    TEST_ASSERT(p1_again);

    // If reset truly rewound, the first allocation after reset should come from the start again.
    // In a typical arena, this ends up being the same address as the first allocation.
    TEST_ASSERT(p1_again == p1);

    printf("[PASS] reset-reuse\n");
}

/* -------------------------------------
   Optional: a tiny "smoke test" wrapper
   ------------------------------------- */
void test_arena_all(Arena* arena) {
    ARENA_DUMP("before arena alignment", arena);
    test_arena_alignment(arena);
    ARENA_DUMP("after arena alignment", arena);

    ARENA_DUMP("before arena no overlap", arena);
    test_arena_no_overlap(arena);
    ARENA_DUMP("after arena no overlap", arena);

    ARENA_DUMP("before block growth", arena);
    test_arena_block_growth(arena);
    ARENA_DUMP("after block growth", arena);

    // Since this test is failing due to previous test creating a new curr_block 
    arena_destroy(arena);
    Arena a = {0};
    arena_init(&a, 256);
    ARENA_DUMP("before arena reset-reuse", arena);
    test_arena_reset_reuse(&a);
    ARENA_DUMP("after arena reset-reuse", arena);
}

/* View memory as hexdump (with ASCII gutter) */
static void hexdump_lines(const void* p, size_t n) {
    const unsigned char* b = (const unsigned char*)p;

    for (size_t i = 0; i < n; i += 16) {
        size_t line_n = (n - i < 16) ? (n - i) : 16;

        // Address
        printf("    %p: ", (const void*)(b + i));

        // Hex bytes
        for (size_t j = 0; j < 16; j++) {
            if (j < line_n) printf("%02X ", b[i + j]);
            else printf("   ");
        }

        // ASCII (printable bytes)
        printf(" |");
        for (size_t j = 0; j < line_n; j++) {
            unsigned char c = b[i + j];
            printf("%c", (c >= 32 && c <= 126) ? (char)c : '.');
        }
        printf("|\n");
    }
}

/* Print arena memory layout + a hexdump of block data */
void arena_print_layout(const Arena* arena) {
    if (!arena) {
        printf("Arena: (null)\n");
        return;
    }
    if (!arena->start_block) {
        printf("Arena: (empty) start_block=NULL\n");
        return;
    }

    const MemBlock* b = arena->start_block;
    int i = 0;
    while (b) {
        size_t used = b->used;
        size_t cap  = b->capacity;

        printf("Block %d: %p  used=%zu  cap=%zu  data=%p  next=%p\n",
               i, (void*)b, used, cap, (void*)b->data, (void*)b->next);

        // Decide how many bytes to dump:
        // - dump what’s actually used (so you see your 0xAA/0x5A fills)
        // - cap to keep output manageable
        size_t dump_n = used;
        if (dump_n > cap) dump_n = cap; // sanity clamp
        if (dump_n > ARENA_DUMP_MAX_BYTES_PER_BLOCK) dump_n = ARENA_DUMP_MAX_BYTES_PER_BLOCK;

        if (dump_n == 0) {
            printf("    (no used bytes)\n");
        } else {
            printf("    dump first %zu byte(s) of data:\n", dump_n);
            hexdump_lines(b->data, dump_n);
        }

        b = b->next;
        i++;
    }
}

```

File: /Users/Maksimus/Documents/GitHub/max--/src/ast/lexer/lexer.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "common.h"
#include "ast/lexer/lexer.h"

// TODO: Consider putting helpers inside 'lexer_helper.c' or something
// TODO: Lex negative integers.

static inline int is_ident_starter(char c) {
    return isalpha((unsigned char)c) || c == '_';
}

static inline int is_ident_char(char c) {
    return isalnum((unsigned char)c) || c == '_';
}

static inline int is_whitespace_char(char c) {
    return c == '\n' || c == ' ' || c == '\t';
}

static inline int is_comment_or_div_starter(char* buf, int i) {
    // For both single/multi-line and division op
    if (buf[i] == '/') {
        return (buf[i+1] == '/' || buf[i+1] == '*' || is_whitespace_char(buf[i+1]));
    }
    return 0;
}

static inline int is_sl_comment(char* buf, int i) {
    return buf[i+1] == '/';
}

static inline int is_ml_comment(char* buf, int i) {
    if (buf[i] != '\0') {
        return buf[i+1] == '*';
    }
    // TODO: Error handle; if we get here the the ML comment reached EOF.
    // Need to refactor a lot for error handling. Sounds cringe.
    return 0;
}

static inline int is_div_op(char* buf, int i) {
    return is_whitespace_char(buf[i+1]);
}

static enum TokenKind get_keyword(char* buf, int i, int length) {
    enum TokenKind token_kind = IDENTIFIER;
    char *p = buf + i;
    switch (length) {
        case 2:
            if (memcmp(p, "if", 2) == 0) token_kind = IF;
            else if (memcmp(p, "fn", 2) == 0) token_kind = FN;
            break;

        case 3:
            if (memcmp(p, "int", 3) == 0) token_kind = INT;
            break;

        case 4:
            if (memcmp(p, "void", 4) == 0) token_kind = VOID;
            break;
        
        case 5:
            if (memcmp(p, "while", 5) == 0) token_kind = WHILE;
            break;

        case 6:
            if (memcmp(p, "return", 6) == 0) token_kind = RETURN;
            break;

        default:
            token_kind = IDENTIFIER;
    }
    return token_kind;
}

static int get_whitespace_len(char* buf, int i) {
    int start = i;
    while (is_whitespace_char(buf[i]) && (buf[i] != '\0')) i++;
    return i - start;
}

static int get_sl_comment_len(char* buf, int i) {
    // Assumes we know we're in a comment.
    // Moves index pointer to after the comment.
    int start = i;
    while (buf[i] != '\n' && buf[i] != '\0') i++;
    return i - start;
}

static int get_ml_comment_len(char* buf, int i) {
    // Assumes we know we're in a comment.
    // Moves index pointer to after the comment.
    int start = i;
    while (buf[i] != '\0')  {
        if (buf[i] == '*' && buf[i+1] == '/') return i+1-start;
        i++;
    }
    return i - start;
}

static int get_digit_length(char* buf, int i) {
    int start = i;
    while (isdigit((unsigned char)buf[i])) i++;
    return i - start;
}

static int get_identifier_len(char* buf, int i) {
    // Checks if the following word is any
    // identifier. I'll check keywords after.
    // returns index pointer to end of identifier.
    int start = i;
    if (is_ident_starter(buf[i])) {
        i++;
        while (is_ident_char(buf[i])) i++;
    }
    return i - start;
}


Token set_token(enum TokenKind type, int start, int line, int col, int length) {
    Token token;
    token.token_kind = type;
    token.start = start;
    token.length = length;
    token.line = line;
    token.col = col;

    return token;
}

void ensure_capacity(TokenBuffer* tokens) {
    if (tokens->capacity == tokens->count) {
        size_t new_capacity = tokens->capacity * 2;
        Token* new_data = realloc(tokens->data, sizeof(Token) * new_capacity);
        if (!new_data) {
            // TODO: Error handle better.
            fprintf(stderr, "ERROR: Could not re-allocate buffer.");
        }
        tokens->data = new_data;
        tokens->capacity = new_capacity;
    }
}

void push_token(TokenBuffer* tokens, Token token) {
    // TODO: Handle errors pushing tokens!
    ensure_capacity(tokens);
    tokens->data[tokens->count] = token;
    tokens->count++;
}

Result lex_input(TokenBuffer* tokens, Source* source_file) {

    // idea:
    // go char by char
    // if i see the start of a keyword:
    // check if it is the keyword
    // if it is, store its line, col,
    // length, and start.

    // TODO: actually use result or just refactor its use case
    // TODO: Fix col bug, when it's a newline, col is incorrect (up by 1).

    Result result;
    result.error_code = 0;
    result.error_message = "";

    int i = 0;
    int line = 1;
    int col = 0;

    while ((size_t)i < source_file->length) {
        char c = source_file->buffer[i];
        // TODO: keyword finder, func finder?
        // FOR NOW WE TRY TO SUPPORT:
        // tests/testfiles/simple/int_dec.in
        // tests/testfiles/strings/hello_world.in
        switch (c) {
            // Simple delimiters
            case '=':
                {
                    // TODO: Consider '==' as well.
                    Token token = set_token(EQ, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case ';':
                {
                    Token token = set_token(SEMICOLON, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case ',':
                {
                    Token token = set_token(COMMA, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case '(':
                {
                    Token token = set_token(PAREN_START, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case ')':
                {
                    Token token = set_token(PAREN_END, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case '{':
                {
                    Token token = set_token(CUR_BRACK_START, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case '}':
                {
                    Token token = set_token(CUR_BRACK_END, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case ':':
                {
                    Token token = set_token(COLON, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            // Operations
             case '+':
                {
                    Token token = set_token(PLUS, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case '-':
                {
                    Token token = set_token(MINUS, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case '*':
                {
                    // TODO: Check for exponentiation
                    Token token = set_token(MULT, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case '<':
                {
                    Token token = set_token(LESS_THAN, i, line, col, 1);
                    push_token(tokens, token);
                }
                break;
            case '\n':
                {
                    line++;
                    col = 0;
                }
                break;


            default:
                if (isdigit((unsigned char)c)) {
                    int length = get_digit_length(source_file->buffer, i);
                    Token token = set_token(INT_LITERAL, i, line, col, length);
                    push_token(tokens, token);
                    i = i + length - 1;
                }
                else if (is_ident_starter((unsigned char)c)) {
                    int length = get_identifier_len(source_file->buffer, i);
                    Token token;
                    enum TokenKind token_kind = get_keyword(source_file->buffer, i, length);
                    // TODO: Validate identifier if token_kind is not a keyword
                    // Currently doesn't validate if no invalid keywords exist.
                    token = set_token(token_kind, i, line, col, length);
                    push_token(tokens, token);
                    i = i + length - 1;
                }
                else if (is_whitespace_char((unsigned char)c)){
                    // skip whitespace
                    int length = get_whitespace_len(source_file->buffer, i);
                    i = i + length - 1;
                }
                else if (is_comment_or_div_starter(source_file->buffer, i)) {
                    // skip single line comments
                    // TODO: Skip multi-line here too later, shouldn't be hard.
                    if (is_div_op(source_file->buffer, i)) {
                        Token token = set_token(DIV, i, line, col, 1);
                        push_token(tokens, token);
                    }
                    else if (is_sl_comment(source_file->buffer, i)) {
                        int length = get_sl_comment_len(source_file->buffer, i);
                        i = i + length - 1;
                    }
                    else if (is_ml_comment(source_file->buffer, i)) {
                        int length = get_ml_comment_len(source_file->buffer, i);
                        i = i + length - 1;
                    }
                    
                }
                break;


        }
        col++;
        i++;
    }

    Token token = set_token(TOK_EOF, i, line, col, 1);
    push_token(tokens, token);

    return result;
}

int last_token_is_EOF(TokenBuffer* tokens) {
    return tokens->data[tokens->count-1].token_kind == TOK_EOF;
}

```

File: /Users/Maksimus/Documents/GitHub/max--/src/arena/arena.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdalign.h>
#include <stddef.h>
#include <assert.h>
#include "arena/arena.h"

#define MAX_ALIGN alignof(max_align_t)

size_t max(size_t a, size_t b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

size_t round_up(size_t size, size_t align) {
    /*Gonna write a small example of what's going on here
    because this was confusing me a bit.
    Let's say that base pointer = 1000, used = 22, size=8, align=8.
    We can't do 'store at 1022 (base + used) because 1022 % 8 != 0.
    So we find padding first, and add padding to used.
    In this case, padding = 2, so 1000 + 22 + 2 = 1024 % 8 == 0.
    The aligned is clever bitwise operations to find the padding automatically.
    */
    assert(align && !(align & (align-1))); // assert power of 2
    size_t aligned = (size + (align-1)) & ~(align-1);
    return aligned;
}

int fits_in_current_block(Arena* arena, size_t size, size_t aligned_used) {
    // TODO: add safety checks
    if (arena->curr_block == NULL) {return 0;}
    MemBlock* curr_mem = arena->curr_block;
    if (aligned_used > curr_mem->capacity) { return 0; }
    
    return size <= curr_mem->capacity - aligned_used;
}

MemBlock* create_block(size_t size) {
    // TODO: Check size does not overflow?
    //if (size > SIZE_MAX - sizeof(MemBlock)) return NULL;
    size_t new_block_size = sizeof(MemBlock) + size;
    MemBlock* new_block = malloc(new_block_size);
    if (!new_block) {
        // TODO: Error handle better?
        return NULL;
    }
    new_block->capacity = size;
    new_block->used = 0;
    new_block->next = NULL;

    return new_block;
}

int arena_add_block(Arena* arena, size_t size) {
    MemBlock* new_block = create_block(size);
    if (new_block == NULL) {
        // TODO: Error handle idk
        fprintf(stderr, "Block allocation failed: new block was NULL.");
        return 0;
    }

    if (arena->curr_block) {
        arena->curr_block->next = new_block;
        arena->curr_block = new_block;
        return 1;
    }
    else {
        arena->start_block = new_block;
        arena->curr_block = new_block;
        return 1;
    }
}

size_t choose_block_size(size_t size) {
    // TODO: Actually implement this.
    // I'll handle special cases later. I just
    // wanna try the arena allocator right now.
    return max(DEFAULT_BLOCK_SIZE, size+MAX_ALIGN-1);
}

void bump(Arena* arena, size_t bump_size) {
    // Moves data pointer to correct address
    // (aligned_used + size)
    arena->curr_block->used = bump_size;
}

void* current_ptr(Arena* arena, size_t aligned_used) {
    return arena->curr_block->data + aligned_used;
}

void* arena_alloc(Arena* arena, size_t size, size_t align) {

    if (arena->curr_block == NULL) {
        arena_add_block(arena, choose_block_size(size));
    }

    size_t aligned_used = round_up(arena->curr_block->used, align);
    if (!fits_in_current_block(arena, size, aligned_used)) {
        int success = arena_add_block(arena, choose_block_size(size));
        if (!success) {
            fprintf(stderr, "Failed to add block to arena.");
            return NULL;
        }
        aligned_used = round_up(arena->curr_block->used, align);
    }
    void* p = current_ptr(arena, aligned_used); // answers: where should I place the next block?
    bump(arena, aligned_used+size);
    return p;
}

int arena_init(Arena* arena, size_t size) {
    if (!arena_add_block(arena, choose_block_size(size))) {
        fprintf(stderr, "Failed to initialize arena: adding block failed.");
        return 0;
    }
    return 1;
}

int arena_destroy(Arena* arena) {
    if (!arena || !arena->start_block) {
        fprintf(stderr, "Failed to destroy arena: Arena has no start block.\n");
        return 0;
    }

    MemBlock* block = arena->start_block;
    while (block != NULL) {
        MemBlock* next = block->next;
        free(block);
        block = next;
    }

    arena->start_block = NULL;
    arena->curr_block = NULL;
    return 1;
}

int arena_reset(Arena* arena) {
    if (arena->start_block == NULL) {
        fprintf(stderr, "Failed to reset arena: Arena has no start block.");
        return 1;
    }

    MemBlock* block = arena->start_block;
    while (block->next != NULL) {
        block->used = 0;
        block = block->next;
    }
    block->used = 0;
    arena->curr_block = arena->start_block;
    return 0;
}

```

File: /Users/Maksimus/Documents/GitHub/max--/src/main.c
```c
#include <stdalign.h>
#if defined(MAXC_ARENA_TESTS) && MAXC_ARENA_TESTS
#include "arena/arena_test.h"
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "ast/lexer/lexer.h"
#include "ast/parser/parser.h"
#include "ast/parser/ast_printer.h"
#include "arena/arena.h"
#include "common.h"

#include "debug.h"


// Idea:
// Parse input file given here
// Turn file into AST
// Do all semantic passes (3 so far?)
// Convert to Max IR (MIR)
// Convert MIR to X86
//  Write output to a .m file (i guess? IDK what extension to use haha)
// Use like clang to convert the file into actual bytecode

typedef struct Args Args;
struct Args {
    char* input_path;
    char* output_path;
    short error_code;
    short debug;
};

Args parse_args(int argc, char **argv) {
    Args args;
    args.input_path = NULL;
    args.output_path = NULL;
    args.error_code = 0;
    args.debug = 0;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s file.m\n [-debug]", argv[0]);
        args.error_code = 1;
        return args;
    }
    args.input_path = argv[1];
    for (int i = 1; i < argc; i++) {
        if (argv[i] != NULL && argv[i][0] == '-') {
            if (argv[i][1] == 'd') {
                args.debug = 1;
            }
            /* handle other flags as needed */
        }
    }
    // TODO: Ensure valid input path, check for output path, etc
    args.error_code = 0;
    return args;
}


int main(int argc, char **argv) {
    // Parse input arguments
    Args args = parse_args(argc, argv);
    if (args.error_code != 0) {
        fprintf(stderr, "Error parsing input arguments.");
        return 1;
    }

    // Open file
    FILE *fp = fopen(args.input_path, "r");
    if (!fp) {
        fprintf(stderr, "Cannot open %s: %s\n", argv[1], strerror(errno));
    }
    
    // Read file into buffer.
    // Result just stores error code/messages
    Source source_file;
    // TODO: Check result of filling buffer for errors
    Result buffer_result  = read_source_file(fp, &source_file);
    if (buffer_result.error_code != 0) {
        fprintf(stderr, "Error filling buffer: %s", buffer_result.error_message);
        return 1;
    }
    fclose(fp);

    if (args.debug) {
        printf("%s", source_file.buffer);
        printf("\n\nBuffer size: %d\n", (int)source_file.length);
        printf("--------- LEXER ---------\n");
    }
    
    // Lex the input buffer into tokens
    // TODO: Check result of filling buffer for errors
    int start_size = START_BUFFER_SIZE;
    TokenBuffer tokens;
    tokens.data = malloc(sizeof(Token) * start_size);
    tokens.count = 0;
    tokens.capacity = start_size;

    Result lex_result = lex_input(&tokens, &source_file);
    if (lex_result.error_code != 0) {
        fprintf(stderr, "Error lexing arguments: %s", lex_result.error_message);
    }
    if (!last_token_is_EOF(&tokens)) {
        fprintf(stderr, "Lexing error: last token was not end of file.");
        return 1;
    }

    if (args.debug) {
        print_all_tokens(&tokens, source_file.buffer);
        printf("\n");
        pretty_print_tokens(&tokens, source_file.buffer);
        printf("---------------------\n\n");
    }



    // Create AST based on token buffer
    Arena arena;
    if (!arena_init(&arena, DEFAULT_BLOCK_SIZE)) {
        fprintf(stderr, "Failed to initialize arena in main.");
        return 2;
    }
    Parser parser;
    if (!initialize_parser(&parser, &arena, &tokens)) {
        fprintf(stderr, "Failed to initialize parser.");
        return 2;
    }

    // Parse tokens and construct AST.
    ASTNode* ast_root = build_ast(&parser, &source_file);
    if (print_parser_err_msgs(&parser)) {
        printf("Compilation failed with %zu errors.", parser.error_list_size);
        return 3;
    }

    if (args.debug) {
        printf("------------- AST -------------\n");
        dump_ast(ast_root, &source_file, 0);
    }
    
    /*------------ DEBUGGING ARENA ------------ */
    #if defined(MAXC_ARENA_TESTS) && MAXC_ARENA_TESTS
        Arena a = {0};
        arena_init(&a, 256);

        test_arena_all(&a);

        arena_destroy(&a);
    #endif
    /*------------ DEBUGGING ARENA ------------ */
    
    // Free all memory
    free(tokens.data);
    free_source(&source_file);
    free_ast_arena(&parser);
    
    return 0;

}


```

File: /Users/Maksimus/Documents/GitHub/max--/src/ast/parser/ast_printer.c
```c
#include <stdio.h>
#include <stdlib.h>
#include "ast/parser/ast.h"
#include "common.h"

char* built_in_type_string[TYPE_TOTAL_COUNT] = {
    /*TYPE_INT*/         "int",
    /*TYPE_BOOL*/        "bool",
    /*TYPE_CHAR*/        "char",
};

char* get_type_string(BuiltInType type) {
    return built_in_type_string[type];
}

// Grabs actual string name from span in buffer.
char* start_of_name(SrcSpan span, Source* source_file) {
    return &source_file->buffer[span.start];
}

// Prints a slice of the input file.
void print_file_slice(char* start_ptr, size_t length) {
    for (size_t i = 0; i < length; i++) {
        printf("%c", *(start_ptr + i));
    }
}

// Prints indents equal to number of indents.
void print_indentation(int indent) {
    for (int i = 0; i < indent; i++) {
        printf("  ");
    }
}

/*
(Program
  (VarDecl type=int name=x
    (Int_Lit 123)
    )
)*/
void dump_ast(ASTNode* node, Source* source_file, int indent) {
    print_indentation(indent);
    printf("(");
    switch (node->ast_kind) {
        case AST_PROGRAM:
        {
            printf("Program\n");
            indent++;
            for (size_t i = 0; i < node->node_info.program.body.count; i++) {
                dump_ast(node->node_info.program.body.items[i], source_file, indent);
            }
            indent--;
            print_indentation(indent);
            printf(")\n");
            break;
        }
        case AST_VAR_DEC: 
        {
            // TODO: Check if is 'int x;' or 'int x = 0;'
            char* start_ptr = start_of_name(node->node_info.var_decl.name_span, source_file);

            printf("VarDecl type={%s} name={", get_type_string(node->node_info.var_decl.type));
            print_file_slice(start_ptr, node->node_info.var_decl.name_span.length);
            printf("}\n");

            indent++;
            dump_ast(node->node_info.var_decl.init_expr, source_file, indent);
            indent--;
            print_indentation(indent);
            printf(")\n");
            break;
        }
        case AST_INT_LIT: // leaf
        {
            IntLitInfo int_lit = node->node_info.int_lit;
            printf("IntLit %ld", int_lit.value);
            printf(")\n");
            break;
        }
        case AST_NAME: // leaf
        {
            printf("VarName name={");

            char* start_ptr = start_of_name(node->node_info.var_name.name_span, source_file);
            print_file_slice(start_ptr, node->node_info.var_name.name_span.length);
            printf("})\n");
            break;
        }
        case AST_BLOCK:
        {
            printf("Block\n");
            indent++;
            for (size_t i = 0; i < node->node_info.block_info.body.count; i++) {
                dump_ast(node->node_info.block_info.body.items[i], source_file, indent);
            }
            indent--;
            print_indentation(indent);
            printf(")\n");
            break;
        }
        case AST_EXIT:
        {
            printf("Exit\n");
            indent++;
            dump_ast(node->node_info.exit_info.expr, source_file, indent);
            indent--;
            print_indentation(indent);
            printf(")\n");
            
        }
        default:
            break;
    }
}


```

File: /Users/Maksimus/Documents/GitHub/max--/CMakeLists.txt
```text
cmake_minimum_required(VERSION 3.20)
project(maxc C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin)

# Default to Debug if not specified
if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug CACHE STRING "Build type" FORCE)
endif()

# ---- Options ----
option(MAXC_ARENA_TESTS "Compile arena test code into the binary" OFF)
option(MAXC_SANITIZE "Enable extra warnings + ASan/UBSan" OFF)
option(MAXC_EXPORT_COMPILE_COMMANDS "Export compile_commands.json" OFF)
option(MAXC_ARENA_DUMP "Enable arena memory dumps during arena tests" OFF)


set(CMAKE_EXPORT_COMPILE_COMMANDS ${MAXC_EXPORT_COMPILE_COMMANDS})

# ---- Sources ----
set(MAXC_SOURCES
    src/main.c
    src/ast/lexer/lexer.c
    src/ast/parser/parser.c
    src/ast/parser/ast_printer.c
    src/debug.c
    src/common.c
    src/arena/arena.c
)

if (MAXC_ARENA_TESTS)
    list(APPEND MAXC_SOURCES src/arena/arena_test.c)
endif()

add_executable(maxc ${MAXC_SOURCES})

target_include_directories(maxc PRIVATE
    ${CMAKE_SOURCE_DIR}/include
)

# Let the code know arena tests are available
if (MAXC_ARENA_TESTS)
    target_compile_definitions(maxc PRIVATE MAXC_ARENA_TESTS=1)
endif()

if (MAXC_ARENA_DUMP)
    target_compile_definitions(maxc PRIVATE MAXC_ARENA_DUMP=1)
endif()

# ---- Sanitizers / warnings ----
if (MAXC_SANITIZE)
    target_compile_options(maxc PRIVATE
        -g -O0
        -Wall -Wextra -Wpedantic
    )

    if (CMAKE_C_COMPILER_ID MATCHES "Clang|GNU")
        target_compile_options(maxc PRIVATE
            -fsanitize=address,undefined
            -fno-omit-frame-pointer
        )
        target_link_options(maxc PRIVATE
            -fsanitize=address,undefined
        )
    endif()
endif()

```

File: /Users/Maksimus/Documents/GitHub/max--/include/ast/parser/ast.h
```c
#pragma once
#include "arena/arena.h"
#include "ast/lexer/lexer.h"
#include <stddef.h>

typedef struct ASTNode ASTNode;

/*------ AST HELPERS ------*/
typedef enum ASTKind {
    AST_PROGRAM,
    AST_VAR_DEC,
    AST_INT_LIT,
    AST_NAME, // identifier expression
    AST_EXPR,
    AST_BLOCK,
    AST_EXIT,
    AST_ERROR
} ASTKind;

typedef enum BuiltInType {
    // Always add BuiltInType to string list in ast_printer.c
    TYPE_INT,
    TYPE_BOOL,
    TYPE_CHAR,
    TYPE_TOTAL_COUNT
    // todo: add more types as we go
} BuiltInType;

typedef struct SrcSpan {
    // Used to store variable name + location.
    // TODO: Make helper that computes line/col based on start/length.
    size_t length;
    size_t start;
} SrcSpan;

/*------- INFORMATION STRUCTS -------*/

// NodeList (for funcs, program, blocks, etc)
typedef struct NodeList {
    ASTNode** items;
    size_t count;
    size_t capacity;
} NodeList;

// Entire program
typedef struct ProgramInfo {
    NodeList body;
} ProgramInfo;

// Primitives
typedef struct IntLitInfo{
    SrcSpan string_value;
    long value;
} IntLitInfo;

// Declarations
typedef struct VarDeclInfo {
    SrcSpan name_span;
    enum BuiltInType type;
    ASTNode* init_expr; // = expr;
} VarDeclInfo;

// Variable name
typedef struct VarNameInfo{
    SrcSpan name_span; // var name
} VarNameInfo;

// Blocks
typedef struct BlockInfo {
    NodeList body;
} BlockInfo;

//Built-ins
// Exit
typedef struct ExitInfo {
    SrcSpan func_span;
    ASTNode* expr;
} ExitInfo;

// Expressions?

/*------- AST STRUCTS -------*/
typedef struct ASTNode {

    ASTKind ast_kind;
    SrcSpan span; // location info of entire 'node'

    union {
        ProgramInfo program;
        IntLitInfo int_lit;
        VarDeclInfo var_decl;
        VarNameInfo var_name;
        BlockInfo block_info;
        ExitInfo exit_info;
    } node_info;
} ASTNode;



```

File: /Users/Maksimus/Documents/GitHub/max--/src/common.c
```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

Result read_source_file(FILE* fp, Source* out) {
    // TODO: FREE THE BUFFER AFTER PARSING!
    Result result;
    result.error_code = 0;
    // Seek to end, get location of pointer, tells buffer size
    if (fseek(fp, 0L, SEEK_END) == 0) {
        // Get size of file
        long bufsize = ftell(fp);
        if (bufsize == -1) { /* Error ? */}
        out->length = bufsize;

        // Allocate a buffer to specified size
        out->buffer = malloc(sizeof(char) * (bufsize + 1));

        // Go back to start
        if (fseek(fp, 0L, SEEK_SET) != 0) { /* Error ? */}

        // Read entire file into memory
        size_t new_len = fread(out->buffer, sizeof(char), bufsize, fp);
        if (ferror(fp) != 0) {
            fputs("Error reading file", stderr);
            result.error_message = "Error reading file";
            result.error_code = 1;
        } else {
            out->buffer[new_len++] = '\0';
        }
    }

    return result;
}

void free_source(Source* source) {
    free(source->buffer);
}

// Computes line and column based on current start location.
LineCol get_line_col_from_span(size_t start_loc, Source* source_file) {
    assert(start_loc <= source_file->length);
    LineCol line_col;
    line_col.line = 1;
    line_col.col = 1;

    size_t index = 0;
    while (index < start_loc) {
        char current_char = source_file->buffer[index];
        if (current_char == '\n') {
            line_col.line++;
            line_col.col = 1;
        }
        else {
            line_col.col++;    
        }
        index++;
    }

    return line_col;
}

```

File: /Users/Maksimus/Documents/GitHub/max--/include/ast/lexer/lexer.h
```c
#pragma once
#include <stddef.h>
#include <stdio.h>
#include "common.h"

// Tokens will be stored by their length, and pointer to
// their place in the file being lexed.

// Ensure when you modify this, you modify the string_array inside debug.h.
enum TokenKind {
    // ---- Special tokens ----
    TOK_EOF,

    // ---- Keywords ----
    IF,
    WHILE,
    FN,
    RETURN,
    INT,
    VOID,

    // ---- Identifiers & literals ----
    IDENTIFIER,
    INT_LITERAL,

    // ---- Comments ----
    SL_COMMENT,
    ML_COMMENT,

    // ---- Delimiters / punctuation ----
    CUR_BRACK_START,
    CUR_BRACK_END,
    PAREN_START,
    PAREN_END,
    SEMICOLON,
    COLON,
    COMMA,

    // ---- Operators ----
    PLUS,
    MINUS,
    MULT,
    DIV,
    EQ,
    NEQ,
    LESS_THAN,

    // --- Error token ---
    NO_TOKEN,

    // ---- Token count (for debug) ----
    TOK_COUNT
};

typedef struct Token Token;
struct Token {
    enum TokenKind token_kind;
    size_t length;
    int start;
    int line;
    int col;
};

typedef struct TokenBuffer TokenBuffer;
struct TokenBuffer {
    Token* data;
    size_t count;
    size_t capacity;
};

Result lex_input(TokenBuffer* tokens, Source* source_file);

int last_token_is_EOF(TokenBuffer* tokens);


```

File: /Users/Maksimus/Documents/GitHub/max--/include/arena/arena.h
```c
/* An arena/bump allocator is more efficient with memory and memory freeing.
I'm doing it because I want to learn more about C, as well as for performance.*/
#pragma once
#include <stddef.h>

#define DEFAULT_BLOCK_SIZE (1<<16) // 2 ^ 16, ~64KB

typedef struct MemBlock MemBlock;
struct MemBlock {
    struct MemBlock* next;
    size_t capacity;
    size_t used;
    unsigned char data[];
    /* Writing thsi comment for myself because this is new to me:
    I use 'unsigned char' to tell the compiler it's just a big bag of bytes that I'm managing.
    char is the only type that allows aliasing to arbitrary object representations (and is 1 byte).
    The arena (should) return a void pointer, and I'll cast it to the type I need.
    TODO: I need to also align the bytes (add padding) so memory knows what's happening.

    Ex. my astnode is 12 bytes, but alignment requires 16, I add 4 bytes.
    TODO: Rewrite this
    THIS ALIGNMENT EXAMPLE IS KIND OF WRONG. */
};

typedef struct Arena {
    MemBlock* start_block;
    MemBlock* curr_block;
} Arena;

void* arena_alloc(Arena* arena, size_t size, size_t align);

size_t choose_block_size(size_t size);

int arena_init(Arena* arena, size_t size);

int arena_destroy(Arena* arena);

int arena_reset(Arena* arena);



```

File: /Users/Maksimus/Documents/GitHub/max--/grammar/grammar.txt
```text
# Just a rough idea of what the grammar should look like for max--, for my own reference.

program: (decl|stmt)* EOF;

decl: int_decl
    | fn_decl
    ; #TODO: Add more decls

int_decl: INT IDENTIFIER = expr;
        ;
fn_decl: FN IDENTIFIER((IDENTIFIER: (type) (, IDENTIFIER: type)?)): type? {(decl|stmt)*}


stmt: assn_stmt
    | if_stmt
    | while_stmt
    | block_stmt
    | ret_stmt
    ;

assn_stmt: TYPE IDENTIFIER = expr;
        ;
if_stmt: IF (COND) block_stmt;
        ;
while_stmt: WHILE (COND) block_stmt;
        ;
block_stmt: {decl|stmt};
        ;
ret_stmt: RETURN expr?;
        ;

expr: expr (*|/) expr
    | expr (+|-) expr
    | expr (('<' | '==') expr)?
    | IDENTIFIER
    | INT_LITERAL;


# GPT_GENERATED GRAMMAR:
program := (int_decl | stmt)* EOF

int_decl := 'int' IDENT '=' expr ';'

stmt := block | if | while | return | expr_stmt

expr_stmt := expr ';'

block := '{' (int_decl | stmt)* '}'

if := 'if' '(' cond ')' stmt

while := 'while' '(' cond ')' stmt

cond := expr ('<' | '==') expr
```

File: /Users/Maksimus/Documents/GitHub/max--/include/debug.h
```c
#pragma once
#include "ast/lexer/lexer.h"

static const char* token_kind_str[TOK_COUNT+1] = {
    /* TOK_EOF */          "EOF",

    /* IF */               "IF",
    /* WHILE */            "WHILE",
    /* FN */               "FN",
    /* RETURN */           "RETURN",
    /* INT */              "INT",
    /* VOID */             "VOID",

    /* IDENTIFIER */       "IDENTIFIER",
    /* INT_LITERAL */      "INT_LITERAL",

    /* SL_COMMENT */       "SL_COMMENT",
    /* ML_COMMENT */       "ML_COMMENT",

    /* CUR_BRACK_START */  "{",
    /* CUR_BRACK_END */    "}",
    /* PAREN_START */      "(",
    /* PAREN_END */        ")",
    /* SEMICOLON */        ";",
    /* COLON */            ":",
    /* COMMA */            ",",

    /* PLUS */             "+",
    /* MINUS */            "-",
    /* MULT */             "*",
    /* DIV */              "/",
    /* EQ */               "=",
    /* NEQ */              "!=",
    /* LESS_THAN */        "<",


    /* NO TOKEN */         "NO_TOKEN",
    /* TOKEN COUNT*/       "TOK_COUNT"
};

void print_all_tokens(TokenBuffer* tokens, const char *buffer);
void pretty_print_tokens(TokenBuffer* tokens, const char *buffer);
```

File: /Users/Maksimus/Documents/GitHub/max--/README.md
```markdown
# max--

A compiler for my own language I invented. I haven't made a formal spec website or sheet yet, but I probably will at some point. It'll be kind of like C but a bit nicer (no pointers :) ) Also, it will have heterogeneous containers (like lists in python), mutable by by default types, is statically typed, and... I'll think of more stuff.

The point was to help me learn both how the bootstrapping process works, how to self-host (just for fun), and the fun of inventing my own language.

Right now I'm focusing on max-1, a simple, minimal language spec I can use to help self-host the rest of the compiler. I'll write it in C (I was going to do assembly for pureism but that sounded a bit too painful).

The language will only compile to x86. I could have used LLVM as my target but I wanted to also learn about the backend compilation process.

## Current Progress

Currently lexes functions and integer declarations, and parses integer declarations only.

Working on better error reporting for the parser.

## Basic setup

- Run `./compile.sh`. It'll take care of everything for you :)

If you'd rather configure some stuff:
```
cmake -S . -B build
cmake --build build
```


```

File: /Users/Maksimus/Documents/GitHub/max--/compile.sh
```shell
#!/usr/bin/env bash

# Usage:
# ./compile.sh [-arena_tests] [-compile_commands]
set -euo pipefail

ARENA_TESTS=OFF
SANITIZE=OFF
DUMP=OFF
COMPILE_COMMANDS=OFF

for arg in "$@"; do
  case "$arg" in
    -arena_tests)
      ARENA_TESTS=ON
      SANITIZE=ON
      DUMP=ON
      ;;
    -compile_commands)
      COMPILE_COMMANDS=ON
      ;;
    *)
      echo "Unknown option: $arg"
      echo "Usage: $0 [-arena_tests] [-compile_commands]"
      exit 1
      ;;
  esac
done

cmake -S . -B build \
  -DMAXC_ARENA_TESTS=${ARENA_TESTS} \
  -DMAXC_SANITIZE=${SANITIZE} \
  -DMAXC_ARENA_DUMP=${DUMP} \
  -DMAXC_EXPORT_COMPILE_COMMANDS=${COMPILE_COMMANDS}

cmake --build build


```

File: /Users/Maksimus/Documents/GitHub/max--/include/arena/arena_test.h
```c
// arena_test.h
// Declarations for arena_tests.c helpers.

#ifndef ARENA_TEST_H
#define ARENA_TEST_H

#include <stddef.h>
#include "arena/arena.h"

#ifdef __cplusplus
extern "C" {
#endif

// Test A: alignment is correct
void test_arena_alignment(Arena* arena);

// Test B: allocations don’t overlap / don’t clobber each other
void test_arena_no_overlap(Arena* arena);

// Test C: block growth works (allocating enough to force new blocks)
void test_arena_block_growth(Arena* arena);

// Extra: reset should rewind and reuse memory as expected
void test_arena_reset_reuse(Arena* arena);

// Convenience: run all tests in a reasonable order
void test_arena_all(Arena* arena);

void arena_print_layout(const Arena* arena);

static void hexdump_lines(const void* p, size_t n);

#ifdef __cplusplus
}
#endif

#endif // ARENA_TEST_H

```

File: /Users/Maksimus/Documents/GitHub/max--/src/debug.c
```c
#include "ast/lexer/lexer.h"
#include "debug.h"


void print_all_tokens(TokenBuffer* tokens, const char *buffer) {

    for (int i = 0; i < tokens->count; i++) {
        Token token = tokens->data[i];
        printf(
            "%-10s  '%.*s'  (%d:%d)\n",
            token_kind_str[token.token_kind],
            (int)token.length,
            buffer + token.start,
            token.line,
            token.col
        );
    }
}

void pretty_print_tokens(TokenBuffer* tokens, const char *buffer) {
    for (int i = 0; i < tokens->count; i++) {
        Token token = tokens->data[i];
        printf("%s ", token_kind_str[token.token_kind]);
        fflush(stdout);
    }
    printf("\n");
}
```

File: /Users/Maksimus/Documents/GitHub/max--/include/common.h
```c
#pragma once
#include <stdio.h>

#define START_BUFFER_SIZE 16

// TODO: Result should also return
// a pointer to a struct I need? Right now
// it's kinda useless, could just return int.
struct Result {
    int error_code;
    const char* error_message;
    void* data; // TODO:CHECK if necessary?
};
typedef struct Result Result;

struct Source { // Source file
    const char* path;
    size_t length;
    char* buffer;
};
typedef struct Source Source;

typedef struct LineCol {
    size_t line;
    size_t col;
} LineCol;

Result read_source_file(FILE* fp, Source* out); // Should return buffer of file ??
void free_source(Source* s);

LineCol get_line_col_from_span(size_t start_loc, Source* source_file);
```

File: /Users/Maksimus/Documents/GitHub/max--/include/ast/parser/parser.h
```c
#include "ast/parser/ast.h"
#include "ast/lexer/lexer.h"
#include "arena/arena.h"

#define DEFAULT_ERROR_LIST_SIZE 10000

// Stores current index in parsing,
typedef struct Parser Parser;
struct Parser {
    TokenBuffer* tokens;
    int token_index;
    Arena* ast_arena;
    char* error_list[DEFAULT_ERROR_LIST_SIZE];
    size_t error_list_size;
};

ASTNode* build_ast(Parser* parser, Source* source_file);
int initialize_parser(Parser* parser, Arena* arena, TokenBuffer* tokens);
int free_ast_arena(Parser* parser);

// Error helpers
void add_err_msg(Parser* parser, char* err_msg, size_t line, size_t col);
int print_parser_err_msgs(Parser* parser);

```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/ops/complex.in
```in
fn add(x: int, y: int): int {
    return x + y;
}

fn main(): int {

    int x = 1;
    int y = 2;
    int z = (x + 1)-(y*2) + (x-2*y) / (2-x) + 1; // Another comment
    // This is a comment

    return 0;
}
```

File: /Users/Maksimus/Documents/GitHub/max--/include/semantics/scope.h
```c
#include "ast/parser/ast.h"

typedef struct Symbol { 
    SrcSpan symbol_span;
    const char* name;
    struct Symbol* next; 
} Symbol;

typedef struct Scope  { 
    Symbol* symbols; 
    struct Scope* parent; 
} Scope;

typedef struct Resolver { 
    Scope* scope; 
    char** err_list;
} Resolver;
```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/ops/add.in
```in
fn add(int x, int y): int {
    return x + y;
}

fn main(): int {

    int x = 1;
    int y = 2;
    int z = add(x, y);

    return 0;
}
```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/strings/hello_world.in
```in
fn main(): int {

    // TODO: Make hello world script later :p
    // but i wont do strings so IDK
    // TODO: Parse strings in lexer
    print("Hello World!");
    return 0;
}
```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/cf/if-else.in
```in
fn main(): int {

    int x = 1;
    if (x < 1) {
        x = 0;
    }
    else {
        x = 2;
    }
    return 0;
}
```

File: /Users/Maksimus/Documents/GitHub/max--/include/ast/parser/ast_printer.h
```c
#include <stdio.h>
#include <stdlib.h>
#include "ast/parser/ast.h"
#include "common.h"


void dump_ast(ASTNode* node, Source* source_file, int indent);
```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/blocks/block_dec.in
```in
int x = 3;
{ int x = 1; 
    { int x = 2;}
}
exit(0);
```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/decs/int_dec.in
```in
int i = 1;
int j = 2;
int k = i;
int l = j;

exit(i);
```

File: /Users/Maksimus/Documents/GitHub/max--/src/semantics/scope.c
```c
#include <stdlib.h>

#include "debug.h"
#include "ast/parser/ast.h"
```

File: /Users/Maksimus/Documents/GitHub/max--/include/ast/ast_node.h
```c

```

File: /Users/Maksimus/Documents/GitHub/max--/include/errors/diagnostics.h
```c

```

File: /Users/Maksimus/Documents/GitHub/max--/src/errors/diagnostics.c
```c

```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/decs/int_dec.out
```out

```

File: /Users/Maksimus/Documents/GitHub/max--/tests/testfiles/playground/test.m
```objectivec

```

</file_contents>
